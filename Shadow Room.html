<!-- 
Assignment 5 - Shadow Room
William Lowrimore
COSC 4345
-->

<html>
  <style type="text/css">
    canvas {
      background: red;
    }
  </style>

  <script id="vertex-shader" type="x-shader/x-vertex">
    attribute vec4 aPos;
    attribute vec4 aCol;
    varying vec4 v_color;

    void main()
    {
      gl_PointSize = 3.0;
      gl_Position = aPos;
      v_color = aCol;
    }
  </script>

  <script id="fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec4 v_color;

    void main()
    {
       gl_FragColor = v_color;
    }
  </script>

  <script type="text/javascript" src="webgl-utils.js"></script>
  <script type="text/javascript" src="initshaders.js"></script>
  <script type="text/javascript" src="lines.js"></script>
  <script type="text/javascript" src="matrices.js"></script>
  <script type="text/javascript" src="shapes.js"></script>
  <script type="text/javascript" src="lighting.js"></script>

  <script>
    window.addEventListener("keydown", keycheck, false);
    function keycheck(e) {
      if (e.keyCode == "76") {
        // L key, light ray
        showLight = !showLight;
      }
      if (e.keyCode == "32") {
        // Space key, turn light on/off
        lightOn = !lightOn;
      }
      if (e.keyCode == "87") {
        // W key, move light up
        lightMovementY += 100;
      }
      if (e.keyCode == "65") {
        // A key, move light left
        lightMovementX += -100;
      }
      if (e.keyCode == "83") {
        // S key, move light down
        lightMovementY += -100;
      }
      if (e.keyCode == "68") {
        // D key, move light right
        lightMovementX += 100;
      }
    }
  </script>

  <script type="text/javascript">
    var canvas;
    var gl;
    var colorUniformLocation;

    var offset = 0;
    var degrees = 0.0;
    var paused = false;
    var direction = 1.0;
    var showLight = false;
    var lightOn = true;
    var lightMovementX = 0;
    var lightMovementY = 0;

    // Retrieve shapes
    var originalPoints = getCube();
    var roomPoints = getRoom();

    var faces = [
      [0, 1, 3, 2],
      [5, 4, 6, 7],
      [4, 0, 2, 6],
      [1, 5, 7, 3],
      [2, 3, 7, 6],
      [1, 0, 4, 5],
    ];

    var facesRoom = [
      [0, 1, 3, 2],
      [5, 4, 6, 7],
      [4, 0, 2, 6],
      [1, 5, 7, 3],
      [2, 3, 7, 6],
      [1, 0, 4, 5],
    ];

    window.onload = init;

    function render() {
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0.1, 0.1, 0.1, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      offset += 2 * direction;
      degrees += 0.2;
      // Loop time
      if (offset > 500) {
        direction = -1.0;
      }
      if (offset < 0) {
        direction = 1.0;
      }
      if (degrees > 360) {
        degrees = 0;
      }

      // Determine transformations
      var Midentity = IdentityMatrix3D();
      var Mtranslate = TranslateMatrix3D(0, 2, -2.0);
      //Rotate Cube
      var MrotationZ = RotationZMatrix3D(degrees * 1);
      var MrotationY = RotationYMatrix3D(degrees * 2);
      var MrotationX = RotationXMatrix3D(degrees * 3);
      var Mscaling = ScalingMatrix3D(2, 2, 2);

      // Transformation Matrix - Rotate Cube
      var Mrotationtotal = MatrixMultiply3D(MrotationX, MrotationY);
      Mrotationtotal = MatrixMultiply3D(Mrotationtotal, MrotationZ);
      var Mtransform = Mrotationtotal;

      // Rotate Room for lighting
      var MrotationRoomY = RotationYMatrix3D(45);
      var MrotationRoomX = RotationXMatrix3D(0);
      var MtransformRoom = MatrixMultiply3D(MrotationRoomX, MrotationRoomY);

      // View-plane normal vector, N, is P0 - Pref
      // View from above to see floor lighting
      var p0 = [0.0, 75.0, 300.0, 1.0];
      var pref = [0.0, 0.0, 0.0, 1.0];
      var zvp = -400;

      // Move light with keys
      var lightPositions = [[0 + lightMovementX, 0 + lightMovementY, 700.0, 1]];
      var lightDirections = [[0.0, 0.0, -1.0, 1]];

      // Light flicker functionality
      if (!lightOn) {
        lightIntensities = [0.0];
      } else {
        lightIntensities = [1.0];
      }
      var ambientLight = 0.2;
      var surfaceEmission = 0.0;

      var Mwcvc = getWorldToViewingMatrix3D(p0, pref);

      // Parallel Projection
      var p1 = VectorMultiply3D(Mwcvc, p0);
      var p2 = VectorMultiply3D(Mwcvc, pref);
      var VP = [];
      for (var i = 0; i < 4; i++) {
        VP[i] = p2[i] - p1[i];
      }
      var Mparallel = getParallelProjectionMatrix(VP, zvp);
      var Mproject = MatrixMultiply3D(Mparallel, Mwcvc);
      var Mfinal = MatrixMultiply3D(Mproject, Mtransform);
      var MfinalRoom = MatrixMultiply3D(Mproject, MtransformRoom);

      var projectedPoints = [];
      var worldPoints = [];
      var projectedPointsR = [];
      var worldPointsR = [];

      for (var i = 0; i < originalPoints.length; i++) {
        projectedPoints[i] = VectorMultiply3D(Mfinal, originalPoints[i]);
        worldPoints[i] = VectorMultiply3D(Mtransform, originalPoints[i]);
      }

      for (var i = 0; i < roomPoints.length; i++) {
        projectedPointsR[i] = VectorMultiply3D(MfinalRoom, roomPoints[i]);
        worldPointsR[i] = VectorMultiply3D(MtransformRoom, roomPoints[i]);
      }

      // Render each shape (Room then cube)
      renderShape(
        roomPoints,
        facesRoom,
        projectedPointsR,
        worldPointsR,
        p0,
        lightPositions,
        lightDirections,
        lightIntensities,
        ambientLight,
        surfaceEmission,
        showLight,
        Mproject,
        true
      );

      renderShape(
        originalPoints,
        faces,
        projectedPoints,
        worldPoints,
        p0,
        lightPositions,
        lightDirections,
        lightIntensities,
        ambientLight,
        surfaceEmission,
        showLight,
        Mproject,
        false
      );

      requestAnimFrame(render);
    }

    function renderShape(
      points,
      faces,
      projectedPoints,
      worldPoints,
      p0,
      lightPositions,
      lightDirections,
      lightIntensities,
      ambientLight,
      surfaceEmission,
      showLight,
      Mproject,
      isRoom
    ) {
      // Sort faces by depth
      var depth = [];
      var faceOrder = [];
      for (var i = 0; i < faces.length; i++) {
        var pt1 = projectedPoints[faces[i][0]];
        var pt2 = projectedPoints[faces[i][1]];
        var pt3 = projectedPoints[faces[i][2]];
        var pt4 = projectedPoints[faces[i][3]];

        depth[i] = Math.min(
          pt1[2] / pt1[3],
          pt2[2] / pt2[3],
          pt3[2] / pt3[3],
          pt4[2] / pt4[3]
        );
        faceOrder[i] = i;
      }
      for (var i = faces.length - 1; i > 0; i--) {
        for (var j = 0; j < i; j++) {
          if (depth[j] > depth[j + 1]) {
            var t = depth[j];
            depth[j] = depth[j + 1];
            depth[j + 1] = t;
            t = faceOrder[j];
            faceOrder[j] = faceOrder[j + 1];
            faceOrder[j + 1] = t;
          }
        }
      }

      for (var i = 0; i < faces.length; i++) {
        var x = faceOrder[i];
        var pt1 = projectedPoints[faces[x][0]];
        var pt2 = projectedPoints[faces[x][1]];
        var pt3 = projectedPoints[faces[x][2]];
        var pt4 = projectedPoints[faces[x][3]];

        if (visibleFace(pt1, pt2, pt3)) {
          var vertices = [];
          vertices = [
            (0.001 * pt1[0]) / pt1[3],
            (0.001 * pt1[1]) / pt1[3],
            (0.001 * pt2[0]) / pt2[3],
            (0.001 * pt2[1]) / pt2[3],
            (0.001 * pt3[0]) / pt3[3],
            (0.001 * pt3[1]) / pt3[3],
            (0.001 * pt4[0]) / pt4[3],
            (0.001 * pt4[1]) / pt4[3],
          ];

          var wp1 = worldPoints[faces[x][0]];
          var wp2 = worldPoints[faces[x][1]];
          var wp3 = worldPoints[faces[x][2]];
          var wp4 = worldPoints[faces[x][3]];

          var colors = [];
          var rgb = [];
          if (isRoom) {
            var hue = 240.0;
          } else {
            var hue = 5.0;
          }
          var saturation = 1.0;
          var value = 0.0;

          var vec1 = [wp1[0] - wp2[0], wp1[1] - wp2[1], wp1[2] - wp2[2]];
          var vec2 = [wp3[0] - wp2[0], wp3[1] - wp2[1], wp3[2] - wp2[2]];
          var N = crossProduct(vec2, vec1);

          var magnitudeN = Math.sqrt(N[0] * N[0] + N[1] * N[1] + N[2] * N[2]);
          if (magnitudeN > 0) {
            N = [N[0] / magnitudeN, N[1] / magnitudeN, N[2] / magnitudeN];
          }

          var wPArray = [wp1, wp2, wp3, wp4];

          // Loop through each point in the face, determine light intensity
          wPArray.forEach((wp) => {
            var V = [p0[0] - wp[0], p0[1] - wp[1], p0[2] - wp[2]];
            var value = intensity(
              wp,
              N,
              V,
              lightPositions,
              lightDirections,
              lightIntensities,
              ambientLight,
              surfaceEmission
            );
            if (value > 1.0) {
              value = 1.0;
            }
            var rgb = hsv2rgb(hue, saturation, value);
            colors.push(rgb[0], rgb[1], rgb[2], 1.0);
          });

          var program = initShaders(gl, "vertex-shader", "fragment-shader");

          var aPos = gl.getAttribLocation(program, "aPos");
          var aCol = gl.getAttribLocation(program, "aCol");

          var positionBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(vertices),
            gl.STATIC_DRAW
          );

          var colorBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(colors),
            gl.STATIC_DRAW
          );

          gl.useProgram(program);

          gl.enableVertexAttribArray(aPos);
          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

          gl.enableVertexAttribArray(aCol);
          gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
          gl.vertexAttribPointer(aCol, 4, gl.FLOAT, false, 0, 0);

          gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length / 2);

          // Determine if light ray should be rendered (L key)
          if (showLight) {
            renderLight(Mproject);
          }
        }
      }

      // Render light ray
      function renderLight(Mproject) {
        vertices = [];
        colors = [];

        for (var z = 0; z < lightPositions.length; z++) {
          var projectedLight = VectorMultiply3D(Mproject, lightPositions[z]);
          var projectedDir = VectorMultiply3D(Mproject, lightDirections[z]);
          vertices.push(
            (0.001 * projectedLight[0]) / projectedLight[3],
            (0.001 * projectedLight[1]) / projectedLight[3]
          );
          vertices.push(
            (0.001 * projectedDir[0]) / projectedDir[3],
            (0.001 * projectedDir[1]) / projectedDir[3]
          );
          colors.push(1.0, 1.0, 1.0, 1.0);
          colors.push(1.0, 1.0, 1.0, 1.0);
        }
      }

      positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW
      );

      colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

      gl.enableVertexAttribArray(aPos);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(aCol);
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.vertexAttribPointer(aCol, 4, gl.FLOAT, false, 0, 0);

      gl.drawArrays(gl.LINES, 0, vertices.length / 2);
    }

    function init() {
      canvas = document.getElementById("gl-canvas");
      gl = WebGLUtils.setupWebGL(canvas);
      if (!gl) {
        alert("WebGL isn't available");
      }

      render();
    }
  </script>

  <body>
    <canvas id="gl-canvas" width="500" height="500">
      Oops... your browser doesn't support HTML5's Canvas elements!
    </canvas>
  </body>
</html>
